---
title: 前端性能优化实战
desc: 让你的 React 应用跑得更快的 10 个技巧
date: 2024-01-05
icon: ⚡
tags:
  - 性能优化
  - React
  - 前端开发
  - 最佳实践
  - 实战
---

性能优化是前端开发中永恒的话题。本文将分享经过实践验证的性能优化技巧，让你的React应用更快速、更流畅。

## 📋 目录

- [代码分割](#代码分割)
- [组件优化](#组件优化)
- [渲染优化](#渲染优化)
- [资源优化](#资源优化)
- [监控分析](#监控分析)

## 代码分割

### 路由级别的分割

使用React.lazy和Suspense：

```javascript
import { lazy, Suspense } from 'react';

const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));

function App() {
  return (
    <Suspense fallback={<div>加载中...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  );
}
```

### 组件级别的分割

```javascript
const HeavyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  const [showHeavy, setShowHeavy] = useState(false);
  
  return (
    <div>
      <button onClick={() => setShowHeavy(true)}>
        加载重型组件
      </button>
      {showHeavy && (
        <Suspense fallback={<div>加载中...</div>}>
          <HeavyComponent />
        </Suspense>
      )}
    </div>
  );
}
```

## 组件优化

### 1. React.memo()

防止不必要的重渲染：

```javascript
const ExpensiveComponent = React.memo(({ data }) => {
  console.log('渲染了');
  return <div>{/* 复杂渲染 */}</div>;
}, (prevProps, nextProps) => {
  // 自定义比较逻辑
  return prevProps.data.id === nextProps.data.id;
});
```

### 2. useMemo() - 缓存计算结果

```javascript
function ProductList({ products }) {
  // 昂贵计算只执行一次
  const sortedProducts = useMemo(() => {
    return products.sort((a, b) => b.price - a.price);
  }, [products]);
  
  return (
    <div>
      {sortedProducts.map(product => (
        <ProductItem key={product.id} product={product} />
      ))}
    </div>
  );
}
```

### 3. useCallback() - 缓存函数引用

```javascript
function Parent({ data }) {
  // 函数只创建一次
  const handleClick = useCallback((id) => {
    console.log('点击了', id);
  }, []);
  
  return (
    <div>
      {data.map(item => (
        <Child key={item.id} onClick={handleClick} />
      ))}
    </div>
  );
}
```

## 渲染优化

### 虚拟列表

处理大量数据：

```javascript
import { useVirtualizer } from '@tanstack/react-virtual';

function VirtualList({ items }) {
  const parentRef = useRef(null);
  
  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50,
  });
  
  return (
    <div ref={parentRef} style={{ height: '400px', overflow: 'auto' }}>
      <div style={{ height: `${virtualizer.getTotalSize()}px` }}>
        {virtualizer.getVirtualItems().map(virtualItem => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: virtualItem.size,
              transform: `translateY(${virtualItem.start}px)`,
            }}
          >
            {items[virtualItem.index]}
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 图片懒加载

```javascript
const LazyImage = ({ src, alt }) => {
  const [imageSrc, setImageSrc] = useState(null);
  const imgRef = useRef(null);
  
  useEffect(() => {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          setImageSrc(src);
          observer.disconnect();
        }
      });
    });
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, [src]);
  
  return <img ref={imgRef} src={imageSrc || 'placeholder.jpg'} alt={alt} />;
};
```

## 资源优化

### 图片优化

```javascript
// 使用WebP格式
<picture>
  <source srcSet="image.webp" type="image/webp" />
  <img src="image.jpg" alt="描述" />
</picture>

// 响应式图片
<img
  srcSet="image-300w.jpg 300w, image-600w.jpg 600w, image-900w.jpg 900w"
  sizes="(max-width: 600px) 300px, (max-width: 900px) 600px, 900px"
  src="image-900w.jpg"
  alt="描述"
/>
```

### CSS优化

```scss
// 避免深度嵌套
// ❌ 不好的做法
.container {
  .wrapper {
    .content {
      .text {
        color: red;
      }
    }
  }
}

// ✅ 好的做法
.container-text {
  color: red;
}

// 使用CSS变量
:root {
  --primary-color: #00ff00;
  --secondary-color: #ffffff;
}

.terminal {
  color: var(--primary-color);
}
```

### 字体优化

```css
/* 使用font-display: swap */
@font-face {
  font-family: 'CustomFont';
  src: url('font.woff2') format('woff2');
  font-display: swap; /* 优化字体加载 */
}
```

## 监控分析

### Web Vitals

```javascript
import { onCLS, onFID, onLCP } from 'web-vitals';

function sendToAnalytics(metric) {
  // 发送到分析服务
  console.log(metric);
}

onCLS(sendToAnalytics); // Cumulative Layout Shift
onFID(sendToAnalytics); // First Input Delay
onLCP(sendToAnalytics); // Largest Contentful Paint
```

### Performance API

```javascript
// 测量代码执行时间
function measurePerformance(name, fn) {
  performance.mark(`${name}-start`);
  fn();
  performance.mark(`${name}-end`);
  performance.measure(name, `${name}-start`, `${name}-end`);
  
  const measure = performance.getEntriesByName(name)[0];
  console.log(`${name}: ${measure.duration}ms`);
}

measurePerformance('heavy-computation', () => {
  // 执行耗时操作
});
```

## 总结

性能优化是一个持续的过程：

✅ **测量** - 先测量，后优化
✅ **优先级** - 优化影响最大的部分
✅ **平衡** - 在性能和可维护性之间找平衡
✅ **监控** - 持续监控性能指标

记住：过早优化是万恶之源，但要关注用户体验！

---

**工具推荐**：
- Chrome DevTools
- Lighthouse
- WebPageTest
- React DevTools Profiler

